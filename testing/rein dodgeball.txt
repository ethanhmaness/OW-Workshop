settings
{
	lobby
	{
		Map Rotation: After A Game
		Max Spectators: 12
		Max Team 1 Players: 6
		Max Team 2 Players: 6
		Return To Lobby: Never
	}

	modes
	{
		Elimination
		{
			enabled maps
			{
				Ayutthaya
				Lijiang Garden Lunar New Year
				Workshop Chamber
				Workshop Island
				Workshop Island Night
			}
		}

		General
		{
			Capture Objective Tiebreaker: Off
			Draw After Match Time Elapsed With No Tiebreaker: 180
			Limit Roles: 2 Of Each Role Per Team
			Score To Win: 9
		}
	}

	heroes
	{
		General
		{
			Reinhardt
			{
				Charge Cooldown Time: 60%
				Damage Dealt: 10%
				Damage Received: 10%
				Ultimate Generation - Combat Earthshatter: 0%
				Ultimate Generation - Passive Earthshatter: 0%
			}

			enabled heroes
			{
				Reinhardt
			}
		}
	}
}

variables
{
	global:
		0: ARENA_CORNERS
		1: ARENA_SPAWNS
		2: ARENA_NET_ENDPOINTS
		3: ARENA2_CORNERS
		4: ARENA2_SPAWNS
		5: ARENA2_NET_ENDPOINTS
		6: INACTIVE_BALL_POS
		7: MAX_BALL_TIME
		8: singleTickTemp
		9: singleTickTemp2
		10: BALL_COLLISION_RAYS
		11: singleTickTemp3
		12: singleTickTemp4

	player:
		0: swingDirection
		1: swingActive
		2: ballPosArray
		3: ballVelArray
		4: ballRadArray
		5: ballTimerArray
		6: ballTeamEffectArray
		7: ballEnemyEffectArray
		8: singleTickTempP
		9: enemyHit
		10: singleTickTempP2
		11: barrierTimer
		12: isCharging
		13: ultPercent
		14: swingStep
		15: hammerPos
		16: hammerLastPos
		17: chargeSphereArray
		18: chargeRad
}

subroutines
{
	0: destroyOldestBall
	1: ballBouncePhys
	2: customWallBlock
	3: customNetBlock
	4: swingPosTrack
}

rule("testing dummy")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		disabled Create Dummy Bot(Hero(Reinhardt), Team 1, 5, Vector(0, 0, 0), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Reinhardt), Team 1, 4, Vector(0, 0, 0), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Reinhardt), Team 1, 3, Vector(0, 0, 0), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Reinhardt), Team 1, 2, Vector(0, 0, 0), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Reinhardt), Team 1, 1, Vector(0, 0, 0), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Reinhardt), Team 1, 0, Vector(0, 0, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Reinhardt), Team 2, 5, Vector(0, 0, 0), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Reinhardt), Team 2, 4, Vector(0, 0, 0), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Reinhardt), Team 2, 3, Vector(0, 0, 0), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Reinhardt), Team 2, 2, Vector(0, 0, 0), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Reinhardt), Team 2, 1, Vector(0, 0, 0), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Reinhardt), Team 2, 0, Vector(0, 0, 0), Vector(0, 0, 0));
	}
}

rule("test")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Interact) == True;
		Host Player == Event Player;
	}

	actions
	{
		Press Button(All Players(All Teams), Ability 2);
		Wait(1, Ignore Condition);
		Press Button(All Players(All Teams), Ability 1);
	}
}

rule("testing teleport")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		If(Team Of(Event Player) == Team 1);
			Teleport(Event Player, Global.ARENA_SPAWNS[0]);
			Set Facing(Event Player, Direction Towards(Global.ARENA_SPAWNS[0], Global.ARENA_SPAWNS[1]), To World);
		Else If(Team Of(Event Player) == Team 2);
			Teleport(Event Player, Global.ARENA_SPAWNS[1]);
			Set Facing(Event Player, Direction Towards(Global.ARENA_SPAWNS[1], Global.ARENA_SPAWNS[0]), To World);
		End;
	}
}

rule("host sees lag-o-meter")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create HUD Text(Host Player, Null, Custom String("Load Avg./Peak"), Custom String("{0}/{1}", Server Load Average,
			Server Load Peak), Right, 0, White, White, White, Visible To and String, Default Visibility);
		disabled Create HUD Text(Host Player, Position Of(Host Player), Null, Null, Left, 0, White, White, White, Visible To and String,
			Default Visibility);
	}
}

rule("no inspector (decreases lag)")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Disable Inspector Recording;
	}
}

rule("skip assembling")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Assembling Heroes == True;
	}

	actions
	{
		Set Match Time(0);
	}
}

rule("arena setup (corners must be on same y-level, does not support concave shapes)")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Up to 2 separate arenas may be defined per map. If 2 are defined, they will be alternated between each round."
		If(Current Map == Map(Ayutthaya));
			Global.ARENA_CORNERS = Array(Vector(0, 21, -50), Vector(36, 21, -50), Vector(36, 21, -100), Vector(0, 21, -100));
			Global.ARENA_SPAWNS = Array(Vector(18, 21, -62.500), Vector(18, 21, -87.500));
			Global.ARENA_NET_ENDPOINTS = Array(Vector(0, 21, -75), Vector(36, 21, -75));
			Global.ARENA2_CORNERS = Array(Vector(38, 21, 42), Vector(38, 21, 87), Vector(-4, 21, 87), Vector(-4, 21, 42));
			Global.ARENA2_SPAWNS = Array(Vector(17, 21, 53.250), Vector(17, 21, 75.750));
			Global.ARENA2_NET_ENDPOINTS = Array(Vector(-4, 21, 64.500), Vector(38, 21, 64.500));
		Else If(Current Map == Map(Lijiang Garden Lunar New Year));
			Global.ARENA_CORNERS = Array(Vector(32, 225, 258), Vector(8, 225, 217), Vector(-8, 225, 217), Vector(-32, 225, 258));
			Global.ARENA_SPAWNS = Array(Vector(16, 225, 244), Vector(-16, 225, 244));
			Global.ARENA_NET_ENDPOINTS = Array(Vector(0, 225, 217), Vector(0, 225, 258));
		Else If(Current Map == Map(Workshop Island));
			Global.ARENA_CORNERS = Array(Vector(-20, 0, -20), Vector(20, 0, -20), Vector(20, 0, 20), Vector(-20, 0, 20));
			Global.ARENA_SPAWNS = Array(Vector(10, 0, 0), Vector(-10, 0, 0));
			Global.ARENA_NET_ENDPOINTS = Array(Vector(0, 0, -20), Vector(0, 0, 20));
		Else If(Current Map == Map(Workshop Island Night));
			Global.ARENA_CORNERS = Array(Vector(-20, 0, -20), Vector(20, 0, -20), Vector(20, 0, 20), Vector(-20, 0, 20));
			Global.ARENA_SPAWNS = Array(Vector(7, 0, -7), Vector(-7, 0, 7));
			Global.ARENA_NET_ENDPOINTS = Array(Vector(-20, 0, -20), Vector(20, 0, 20));
		Else If(Current Map == Map(Workshop Chamber));
			Global.ARENA_CORNERS = Array(Vector(-21, 0, -21), Vector(21, 0, -21), Vector(21, 0, 21), Vector(-21, 0, 21));
			Global.ARENA_SPAWNS = Array(Vector(10, 0, 0), Vector(-10, 0, 0));
			Global.ARENA_NET_ENDPOINTS = Array(Vector(0, 0, -21), Vector(0, 0, 21));
			Global.ARENA2_CORNERS = Array(Vector(-8.700, 46, 21), Vector(8.700, 46, 21), Vector(21, 46, 8.700), Vector(21, 46, -8.700), Vector(
				8.700, 46, -21), Vector(-8.700, 46, -21), Vector(-21, 46, -8.700), Vector(-21, 46, 8.700));
			Global.ARENA2_SPAWNS = Array(Vector(0, 46, 10), Vector(0, 46, -10));
			Global.ARENA2_NET_ENDPOINTS = Array(Vector(21, 46, 0), Vector(-21, 46, 0));
		Else If(Current Map == Map(Workshop Expanse Night));
			Global.ARENA_CORNERS = Array(Vector(384, 0, 345.530), Vector(384, 0, 374.919), Vector(356.050, 0, 384), Vector(338.775, 0,
				360.224), Vector(356.050, 0, 336.448));
			Global.ARENA_SPAWNS = Array(Vector(363, 0, 346), Vector(363, 0, 374));
			Global.ARENA_NET_ENDPOINTS = Array(Vector(384, 0, 360.224), Vector(338.775, 0, 360.224));
			Global.ARENA2_CORNERS = Array(Vector(-384, 0, -376), Vector(-376, 0, -384), Vector(-356, 0, -384), Vector(-340, 0, -368), Vector(
				-340, 0, -348), Vector(-348, 0, -340), Vector(-368, 0, -340), Vector(-384, 0, -356));
			Global.ARENA2_SPAWNS = Array(Vector(-351, 0, -351), Vector(-373, 0, -373));
			Global.ARENA2_NET_ENDPOINTS = Array(Vector(-348, 0, -376), Vector(-376, 0, -348));
	}
}

rule("arena visuals")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.ARENA_CORNERS != 0;
	}

	actions
	{
		"arena"
		For Global Variable(singleTickTemp, 0, Count Of(Global.ARENA_CORNERS), 1);
			Create Beam Effect(All Players(All Teams), Bad Beam, Global.ARENA_CORNERS[Global.singleTickTemp] + Up * 0.200,
				Global.ARENA_CORNERS[(Global.singleTickTemp + 1) % Count Of(Global.ARENA_CORNERS)] + Up * 0.200, Red, Visible To);
		End;
		Create Beam Effect(All Players(All Teams), Good Beam, Global.ARENA_NET_ENDPOINTS[0] + Up * 0.200,
			Global.ARENA_NET_ENDPOINTS[1] + Up * 0.200, White, Visible To);
		"dont build second arena if not defined"
		Abort If(Global.ARENA2_CORNERS == 0);
		"arena2"
		For Global Variable(singleTickTemp, 0, Count Of(Global.ARENA2_CORNERS), 1);
			Create Beam Effect(All Players(All Teams), Bad Beam, Global.ARENA2_CORNERS[Global.singleTickTemp] + Up * 0.200,
				Global.ARENA2_CORNERS[(Global.singleTickTemp + 1) % Count Of(Global.ARENA2_CORNERS)] + Up * 0.200, Red, Visible To);
		End;
		Create Beam Effect(All Players(All Teams), Good Beam, Global.ARENA2_NET_ENDPOINTS[0] + Up * 0.200,
			Global.ARENA2_NET_ENDPOINTS[1] + Up * 0.200, White, Visible To);
	}
}

rule("init global vars")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.INACTIVE_BALL_POS = Vector(0, -100, 0);
		Global.MAX_BALL_TIME = 5;
		"relative normalized coordinates of ray endpoints for rudimentary spherecast approximation for ball projectile collisions (5 points)"
		Global.BALL_COLLISION_RAYS = Array(Forward, Down, Left, Right, Up);
	}
}

rule("init player balls")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.ballPosArray[0] = Global.INACTIVE_BALL_POS;
		Create Effect(All Players(Team Of(Event Player)), Sphere, Orange, Event Player.ballPosArray[0], Event Player.ballRadArray[0],
			Visible To Position and Radius);
		Event Player.ballTeamEffectArray[0] = Last Created Entity;
		Create Effect(All Players(Opposite Team Of(Team Of(Event Player))), Sphere, Red, Event Player.ballPosArray[0],
			Event Player.ballRadArray[0], Visible To Position and Radius);
		Event Player.ballEnemyEffectArray[0] = Last Created Entity;
		Event Player.ballPosArray[1] = Global.INACTIVE_BALL_POS;
		Create Effect(All Players(Team Of(Event Player)), Sphere, Orange, Event Player.ballPosArray[1], Event Player.ballRadArray[1],
			Visible To Position and Radius);
		Event Player.ballTeamEffectArray[1] = Last Created Entity;
		Create Effect(All Players(Opposite Team Of(Team Of(Event Player))), Sphere, Red, Event Player.ballPosArray[1],
			Event Player.ballRadArray[1], Visible To Position and Radius);
		Event Player.ballEnemyEffectArray[1] = Last Created Entity;
		Event Player.ballPosArray[2] = Global.INACTIVE_BALL_POS;
		Create Effect(All Players(Team Of(Event Player)), Sphere, Orange, Event Player.ballPosArray[2], Event Player.ballRadArray[2],
			Visible To Position and Radius);
		Event Player.ballTeamEffectArray[2] = Last Created Entity;
		Create Effect(All Players(Opposite Team Of(Team Of(Event Player))), Sphere, Red, Event Player.ballPosArray[2],
			Event Player.ballRadArray[2], Visible To Position and Radius);
		Event Player.ballEnemyEffectArray[2] = Last Created Entity;
	}
}

rule("remove effects on player leave")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	actions
	{
		For Global Variable(singleTickTemp, 0, Count Of(Event Player.ballTeamEffectArray), 1);
			Destroy Effect(Event Player.ballTeamEffectArray[0]);
		End;
		For Global Variable(singleTickTemp, 0, Count Of(Event Player.ballEnemyEffectArray), 1);
			Destroy Effect(Event Player.ballEnemyEffectArray[0]);
		End;
	}
}

rule("teleport players to arena on match start (and swap arena if 2 are present)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Assembling Heroes == False;
	}

	actions
	{
		If(Global.ARENA2_CORNERS != 0);
			Global.singleTickTemp = Global.ARENA_CORNERS;
			Global.singleTickTemp2 = Global.ARENA_SPAWNS;
			Global.singleTickTemp3 = Global.ARENA_NET_ENDPOINTS;
			Global.ARENA_CORNERS = Global.ARENA2_CORNERS;
			Global.ARENA_SPAWNS = Global.ARENA2_SPAWNS;
			Global.ARENA_NET_ENDPOINTS = Global.ARENA2_NET_ENDPOINTS;
			Global.ARENA2_CORNERS = Global.singleTickTemp;
			Global.ARENA2_SPAWNS = Global.singleTickTemp2;
			Global.ARENA2_NET_ENDPOINTS = Global.singleTickTemp3;
		End;
		Small Message(All Players(All Teams), Custom String("5"));
		Wait(1, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("4"));
		Wait(1, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("3"));
		Wait(1, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("2"));
		Wait(1, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("1"));
		Wait(1, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("Play Ball!"));
		Teleport(All Players(Team 1), Global.ARENA_SPAWNS[0]);
		Set Facing(All Players(Team 1), Direction Towards(Global.ARENA_SPAWNS[0], Global.ARENA_SPAWNS[1]), To World);
		Teleport(All Players(Team 2), Global.ARENA_SPAWNS[1]);
		Set Facing(All Players(Team 2), Direction Towards(Global.ARENA_SPAWNS[1], Global.ARENA_SPAWNS[0]), To World);
	}
}

rule("player tick events")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		"// All the 0.016s ongoing - each player loops have to go in the same rule to avoid tickskipping because workshop is jank"
		True == True;
	}

	actions
	{
		"barrier cancel"
		If(Event Player.barrierTimer > 2.500 || !Is Firing Secondary(Event Player));
			If(Is Firing Secondary(Event Player));
				Cancel Primary Action(Event Player);
			End;
			Event Player.barrierTimer = 0;
		End;
		"hammer swing tracker"
		If(Event Player.swingActive);
			Event Player.swingStep += 1;
			Call Subroutine(swingPosTrack);
		Else If(Event Player.swingStep != 0);
			Event Player.swingStep = 0;
			Event Player.hammerPos = 0;
			Event Player.hammerLastPos = 0;
		End;
		If(!Is Firing Primary(Event Player));
			Event Player.swingDirection = 0;
			Event Player.swingActive = False;
		End;
		"charging sphere"
		If(Event Player.isCharging == True);
			If(Event Player.chargeSphereArray == 0);
				Create Effect(All Players(Team Of(Event Player)), Sphere, Orange, Event Player, Event Player.chargeRad,
					Visible To Position and Radius);
				Event Player.chargeSphereArray[0] = Last Created Entity;
				Create Effect(All Players(Opposite Team Of(Team Of(Event Player))), Sphere, Red, Event Player, Event Player.chargeRad,
					Visible To Position and Radius);
				Event Player.chargeSphereArray[1] = Last Created Entity;
				Event Player.chargeRad = 0.500;
			Else If(Event Player.chargeRad < 1.500);
				Event Player.chargeRad += 0.016;
			End;
		End;
		"destroy old balls"
		If(Is True For Any(Event Player.ballTimerArray, Current Array Element > 5));
			Call Subroutine(destroyOldestBall);
		End;
		"update ult charge"
		If(Event Player.ultPercent != Ultimate Charge Percent(Event Player));
			Set Ultimate Charge(Event Player, Event Player.ultPercent);
		End;
		"increment barrier timer"
		If(Is Firing Secondary(Event Player));
			Event Player.barrierTimer += 0.016;
			Set Ability Cooldown(Event Player, Button(Secondary Fire), Max(2, Event Player.barrierTimer * 2));
		End;
		"block living players from passing through custom wall"
		If(Is Alive(Event Player) && Has Spawned(Event Player));
			Global.singleTickTemp = Position Of(Event Player);
			Call Subroutine(customNetBlock);
			"block player passing through custom wall"
			For Global Variable(singleTickTemp2, 0, Count Of(Global.ARENA_CORNERS), 1);
				Call Subroutine(customWallBlock);
			End;
		End;
		"ball collisions"
		For Global Variable(singleTickTemp, 0, Count Of(Event Player.ballPosArray), 1);
			If(Event Player.ballPosArray[Global.singleTickTemp] != Global.INACTIVE_BALL_POS);
				Call Subroutine(ballBouncePhys);
				If(Event Player.enemyHit != 0);
					Kill(Event Player.enemyHit, Event Player);
					Event Player.enemyHit = 0;
				End;
			End;
		End;
		Wait(0.016, Ignore Condition);
		"kinematics updates"
		For Global Variable(singleTickTemp, 0, Count Of(Event Player.ballPosArray), 1);
			If(Event Player.ballPosArray[Global.singleTickTemp] != Global.INACTIVE_BALL_POS);
				Event Player.ballTimerArray[Global.singleTickTemp] += 0.016;
				Event Player.ballPosArray[Global.singleTickTemp] += 0.016 * Event Player.ballVelArray[Global.singleTickTemp];
				Event Player.ballVelArray[Global.singleTickTemp] += Down * 20 * 0.016;
			End;
		End;
		Loop If Condition Is True;
	}
}

rule("Subroutine destroyOldestBall")
{
	event
	{
		Subroutine;
		destroyOldestBall;
	}

	actions
	{
		"temp = oldest ball index"
		Global.singleTickTemp = Index Of Array Value(Event Player.ballTimerArray, Last Of(Sorted Array(Event Player.ballTimerArray,
			Current Array Element)));
		Play Effect(All Players(Team Of(Event Player)), Good Explosion, Orange, Event Player.ballPosArray[Global.singleTickTemp],
			Event Player.ballRadArray[Global.singleTickTemp]);
		Play Effect(All Players(Opposite Team Of(Team Of(Event Player))), Good Explosion, Red,
			Event Player.ballPosArray[Global.singleTickTemp], Event Player.ballRadArray[Global.singleTickTemp]);
		Event Player.ballPosArray[Global.singleTickTemp] = Global.INACTIVE_BALL_POS;
		Event Player.ballVelArray[Global.singleTickTemp] = 0;
		Event Player.ballRadArray[Global.singleTickTemp] = 0;
		Event Player.ballTimerArray[Global.singleTickTemp] = 0;
	}
}

rule("Subroutine ballBouncePhys")
{
	event
	{
		Subroutine;
		ballBouncePhys;
	}

	actions
	{
		Event Player.singleTickTempP = 0;
		Event Player.singleTickTempP2 = 0;
		"collisions with surfaces, barriers, enemies, etc."
		For Global Variable(singleTickTemp2, 0, Count Of(Global.BALL_COLLISION_RAYS), 1);
			"stop looping once a collision is found"
			If(Event Player.enemyHit != 0 || Event Player.singleTickTempP2 != 0);
				Break;
			End;
			"singleTickTempP = the endpoint of the collision detection ray currently being evaluated"
			Event Player.singleTickTempP = Event Player.ballPosArray[Global.singleTickTemp] + Event Player.ballRadArray[Global.singleTickTemp] * Direction From Angles(
				Horizontal Angle From Direction(Event Player.ballVelArray[Global.singleTickTemp]) + Horizontal Angle From Direction(
				Global.BALL_COLLISION_RAYS[Global.singleTickTemp2]), Vertical Angle From Direction(
				Event Player.ballVelArray[Global.singleTickTemp]) + Vertical Angle From Direction(
				Global.BALL_COLLISION_RAYS[Global.singleTickTemp2]));
			Event Player.enemyHit = Ray Cast Hit Player(Event Player.ballPosArray[Global.singleTickTemp], Event Player.singleTickTempP,
				All Living Players(Opposite Team Of(Team Of(Event Player))), Null, True);
			If(Ray Cast Hit Position(Event Player.ballPosArray[Global.singleTickTemp], Event Player.singleTickTempP, All Living Players(
				Opposite Team Of(Team Of(Event Player))), Null, True) != Event Player.singleTickTempP);
				"singleTickTempP2 = normal of the surface being collided with"
				Event Player.singleTickTempP2 = Ray Cast Hit Normal(Event Player.ballPosArray[Global.singleTickTemp], Event Player.singleTickTempP,
					All Living Players(Opposite Team Of(Team Of(Event Player))), Null, True);
				If(Angle Between Vectors(Event Player.singleTickTempP2, Event Player.ballVelArray[Global.singleTickTemp]) > 90);
					"reflected vector = vector - 2 * normal * (vector•normal)"
					Event Player.ballVelArray[Global.singleTickTemp] = Event Player.ballVelArray[Global.singleTickTemp] - 2 * Event Player.singleTickTempP2 * Dot Product(
						Event Player.ballVelArray[Global.singleTickTemp], Event Player.singleTickTempP2);
					Play Effect(All Players(Team Of(Event Player)), Bad Explosion, Orange, Event Player.singleTickTempP, 0.250);
					Play Effect(All Players(Opposite Team Of(Team Of(Event Player))), Bad Explosion, Red, Event Player.singleTickTempP, 0.250);
				End;
			End;
		End;
		"collisions with arena border"
		For Global Variable(singleTickTemp2, 0, Count Of(Global.ARENA_CORNERS), 1);
			"current corner"
			Global.singleTickTemp3 = Global.ARENA_CORNERS[Global.singleTickTemp2];
			"next corner"
			Global.singleTickTemp4 = Global.ARENA_CORNERS[(1 + Global.singleTickTemp2) % Count Of(Global.ARENA_CORNERS)];
			"singleTickTempP = vector from corner to closest point on wall to center of ball"
			Event Player.singleTickTempP = Direction Towards(Global.singleTickTemp3, Global.singleTickTemp4) * Dot Product(Vector Towards(
				Global.singleTickTemp3, Event Player.ballPosArray[Global.singleTickTemp]) * Vector(1, 0, 1), Direction Towards(
				Global.singleTickTemp3, Global.singleTickTemp4));
			"bounce if horizontal distance to closest wall point is less than radius"
			If(Distance Between((Global.singleTickTemp3 + Event Player.singleTickTempP) * Vector(1, 0, 1),
				Event Player.ballPosArray[Global.singleTickTemp] * Vector(1, 0, 1)) <= Event Player.ballRadArray[Global.singleTickTemp]);
				"singleTickTempP2 = wall normal"
				Event Player.singleTickTempP2 = Direction Towards((Global.singleTickTemp3 + Event Player.singleTickTempP) * Vector(1, 0, 1),
					Event Player.ballPosArray[Global.singleTickTemp] * Vector(1, 0, 1));
				If(Angle Between Vectors(Event Player.singleTickTempP2, Event Player.ballVelArray[Global.singleTickTemp]) > 90);
					"reflected vector = vector - 2 * normal * (vector•normal)"
					Event Player.ballVelArray[Global.singleTickTemp] = Event Player.ballVelArray[Global.singleTickTemp] - 2 * Event Player.singleTickTempP2 * Dot Product(
						Event Player.ballVelArray[Global.singleTickTemp], Event Player.singleTickTempP2);
					Play Effect(All Players(Team Of(Event Player)), Bad Explosion, Orange, (Global.singleTickTemp3 + Event Player.singleTickTempP)
						* Vector(1, 0, 1) + Up * Y Component Of(Event Player.ballPosArray[Global.singleTickTemp]), 0.250);
					Play Effect(All Players(Opposite Team Of(Team Of(Event Player))), Bad Explosion, Red, (
						Global.singleTickTemp3 + Event Player.singleTickTempP) * Vector(1, 0, 1) + Y Component Of(
						Event Player.ballPosArray[Global.singleTickTemp]), 0.250);
				End;
			End;
		End;
		"collisions with other balls"
		For Global Variable(singleTickTemp2, 0, Count Of(All Players(All Teams)), 1);
			"singleTickTempP = player currently having their balls examined *wink*"
			Event Player.singleTickTempP = All Players(All Teams)[Global.singleTickTemp2];
			"singleTickTempP2 = position of current player's closest ball to this ball (excluding this ball)"
			Event Player.singleTickTempP2 = First Of(Sorted Array(Filtered Array(Event Player.singleTickTempP.ballPosArray,
				Current Array Element != Event Player.ballPosArray[Global.singleTickTemp]), Distance Between(Current Array Element,
				Event Player.ballPosArray[Global.singleTickTemp])));
			If(Event Player.singleTickTempP2 != Global.INACTIVE_BALL_POS && Distance Between(Event Player.ballPosArray[Global.singleTickTemp],
				Event Player.singleTickTempP2)
				<= Event Player.ballRadArray[Global.singleTickTemp] + Event Player.singleTickTempP.ballRadArray[Index Of Array Value(
				Event Player.singleTickTempP.ballPosArray, Event Player.singleTickTempP2)]);
				"reflected vector = vector - 2 * normal * (vector•normal)"
				Event Player.ballVelArray[Global.singleTickTemp] = Event Player.ballVelArray[Global.singleTickTemp] - 2 * Direction Towards(
					Event Player.singleTickTempP2, Event Player.ballPosArray[Global.singleTickTemp]) * Dot Product(
					Event Player.ballVelArray[Global.singleTickTemp], Direction Towards(Event Player.singleTickTempP2,
					Event Player.ballPosArray[Global.singleTickTemp]));
				"teleport other ball to no longer be inside this ball"
				Event Player.singleTickTempP.ballPosArray[Index Of Array Value(Event Player.singleTickTempP.ballPosArray,
					Event Player.singleTickTempP2)] = Event Player.ballPosArray[Global.singleTickTemp] + Direction Towards(
					Event Player.ballPosArray[Global.singleTickTemp], Event Player.singleTickTempP2) * (
					Event Player.ballRadArray[Global.singleTickTemp] + Event Player.singleTickTempP.ballRadArray[Index Of Array Value(
					Event Player.singleTickTempP.ballPosArray, Event Player.singleTickTempP2)]);
				Play Effect(All Players(Team Of(Event Player)), Bad Explosion, Orange,
					Event Player.ballPosArray[Global.singleTickTemp] + Event Player.ballRadArray[Global.singleTickTemp] * Direction Towards(
					Event Player.ballPosArray[Global.singleTickTemp], Event Player.singleTickTempP2), 0.250);
				Play Effect(All Players(Opposite Team Of(Team Of(Event Player))), Bad Explosion, Red,
					Event Player.ballPosArray[Global.singleTickTemp] + Event Player.ballRadArray[Global.singleTickTemp] * Direction Towards(
					Event Player.ballPosArray[Global.singleTickTemp], Event Player.singleTickTempP2), 0.250);
			End;
		End;
		"collisions with hammers"
		For Global Variable(singleTickTemp2, 0, Count Of(All Living Players(All Teams)), 1);
			If(All Living Players(All Teams)[Global.singleTickTemp2].hammerLastPos != 0);
				"singleTickTempP = vector from hammerLastPos to closest point on hammer path to center of ball"
				Event Player.singleTickTempP = Direction Towards(All Living Players(All Teams)[Global.singleTickTemp2].hammerLastPos,
					All Living Players(All Teams)[Global.singleTickTemp2].hammerPos) * Dot Product(Vector Towards(All Living Players(All Teams)
					[Global.singleTickTemp2].hammerLastPos, All Living Players(All Teams)[Global.singleTickTemp2].hammerPos), Direction Towards(
					All Living Players(All Teams)[Global.singleTickTemp2].hammerLastPos, All Living Players(All Teams)
					[Global.singleTickTemp2].hammerPos));
				"bounce if horizontal distance to closest hammer path point is less than radius + hammer radius (0.5)"
				If(Distance Between(All Living Players(All Teams)[Global.singleTickTemp2].hammerLastPos + Event Player.singleTickTempP,
					Event Player.ballPosArray[Global.singleTickTemp]) <= Event Player.ballRadArray[Global.singleTickTemp] + 0.500);
					"ball go in hammer user's facing direction, multiply speed by 1.15"
					Event Player.ballVelArray[Global.singleTickTemp] = Distance Between(Vector(0, 0, 0),
						Event Player.ballVelArray[Global.singleTickTemp]) * 1.150 * Direction From Angles(Horizontal Facing Angle Of(
						All Living Players(All Teams)[Global.singleTickTemp2]), Vertical Facing Angle Of(All Living Players(All Teams)
						[Global.singleTickTemp2]) + -5);
					Play Effect(All Players(All Teams), Bad Explosion, White, All Living Players(All Teams)[Global.singleTickTemp2].hammerPos, 1);
				End;
			End;
		End;
	}
}

rule("Subroutine customWallBlock")
{
	event
	{
		Subroutine;
		customWallBlock;
	}

	actions
	{
		"current corner"
		Global.singleTickTemp3 = Global.ARENA_CORNERS[Global.singleTickTemp2];
		"next corner"
		Global.singleTickTemp4 = Global.ARENA_CORNERS[(1 + Global.singleTickTemp2) % Count Of(Global.ARENA_CORNERS)];
		"singleTickTempP = vector from corner to closest point on wall to center of player"
		Event Player.singleTickTempP = Direction Towards(Global.singleTickTemp3, Global.singleTickTemp4) * Dot Product(Vector Towards(
			Global.singleTickTemp3, Global.singleTickTemp) * Vector(1, 0, 1), Direction Towards(Global.singleTickTemp3,
			Global.singleTickTemp4));
		"push if horizontal distance to closest wall point is less than radius"
		If(Distance Between((Global.singleTickTemp3 + Event Player.singleTickTempP) * Vector(1, 0, 1), Global.singleTickTemp * Vector(1, 0,
			1)) <= 1);
			"singleTickTempP2 = wall normal"
			Event Player.singleTickTempP2 = Direction Towards((Global.singleTickTemp3 + Event Player.singleTickTempP) * Vector(1, 0, 1),
				Global.singleTickTemp * Vector(1, 0, 1));
			Apply Impulse(Event Player, Event Player.singleTickTempP2, 5, To World, Cancel Contrary Motion);
			Apply Impulse(Event Player, Up, 1, To World, Cancel Contrary Motion);
			Set Status(Event Player, Null, Rooted, 0.032);
		End;
	}
}

rule("Subroutine customNetBlock")
{
	event
	{
		Subroutine;
		customNetBlock;
	}

	actions
	{
		"singleTickTempP = vector from corner to closest point on net to center of player"
		Event Player.singleTickTempP = Direction Towards(Global.ARENA_NET_ENDPOINTS[0], Global.ARENA_NET_ENDPOINTS[1]) * Dot Product(
			Vector Towards(Global.ARENA_NET_ENDPOINTS[0], Global.singleTickTemp) * Vector(1, 0, 1), Direction Towards(
			Global.ARENA_NET_ENDPOINTS[0], Global.ARENA_NET_ENDPOINTS[1]));
		"push if horizontal distance to closest wall point is less than radius"
		If(Distance Between((Global.ARENA_NET_ENDPOINTS[0] + Event Player.singleTickTempP) * Vector(1, 0, 1),
			Global.singleTickTemp * Vector(1, 0, 1)) <= 1);
			"singleTickTempP2 = wall normal"
			Event Player.singleTickTempP2 = Direction Towards((Global.ARENA_NET_ENDPOINTS[0] + Event Player.singleTickTempP) * Vector(1, 0, 1),
				Global.singleTickTemp * Vector(1, 0, 1));
			Apply Impulse(Event Player, Event Player.singleTickTempP2, 5, To World, Cancel Contrary Motion);
			Apply Impulse(Event Player, Up, 1, To World, Cancel Contrary Motion);
			Set Status(Event Player, Null, Rooted, 0.032);
		End;
	}
}

rule("Subroutine swingPosTrack")
{
	event
	{
		Subroutine;
		swingPosTrack;
	}

	actions
	{
		"singleTickTemp = hammer angle"
		Global.singleTickTemp = (-1 + 2 * Event Player.swingDirection) * (80 + -20 * (Event Player.swingStep - 1));
		"if first frame, set prev and current to same spot. else, set prev to last frame and current to new frame"
		If(Event Player.swingStep == 1);
			Event Player.hammerPos = Eye Position(Event Player) + Down * 0.100 + 3 * Normalize(Facing Direction Of(Event Player)
				+ World Vector Of(Left * Tangent From Degrees(Global.singleTickTemp), Event Player, Rotation));
			Event Player.hammerLastPos = Event Player.hammerPos;
		Else;
			Event Player.hammerLastPos = Event Player.hammerPos;
			Event Player.hammerPos = Eye Position(Event Player) + Down * 0.100 + 3 * Normalize(Facing Direction Of(Event Player)
				+ World Vector Of(Left * Tangent From Degrees(Global.singleTickTemp), Event Player, Rotation));
		End;
	}
}

rule("swing tracker")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		"0 = right-to-left, 1 = left-to-right"
		Event Player.swingDirection = 0;
		Wait(0.272, Abort When False);
		While(Is Firing Primary(Event Player));
			Event Player.swingActive = True;
			Wait(0.160, Abort When False);
			Event Player.swingActive = False;
			Wait(0.416, Abort When False);
			"alternate between 0 and 1"
			Event Player.swingDirection = (Event Player.swingDirection + 1) % 2;
			Wait(0.432, Abort When False);
		End;
		Event Player.swingDirection = 0;
	}
}

rule("firestrike ball")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(0.464, Abort When False);
		Cancel Primary Action(Event Player);
		"no more than 3 balls at a time"
		If(Count Of(Filtered Array(Event Player.ballPosArray, Current Array Element != Global.INACTIVE_BALL_POS)) >= 3);
			Call Subroutine(destroyOldestBall);
		End;
		Global.singleTickTemp = Index Of Array Value(Event Player.ballPosArray, Global.INACTIVE_BALL_POS);
		Event Player.ballPosArray[Global.singleTickTemp] = Eye Position(Event Player);
		Event Player.ballVelArray[Global.singleTickTemp] = 25 * Direction From Angles(Horizontal Facing Angle Of(Event Player),
			Vertical Facing Angle Of(Event Player) + -5);
		Event Player.ballRadArray[Global.singleTickTemp] = 1;
		Event Player.ballTimerArray[Global.singleTickTemp] = 0;
		"Cooldown shortens with smaller number of players alive"
		Set Ability Cooldown(Event Player, Button(Ability 2), 2 + 4 * (Count Of(All Living Players(All Teams)) / 12));
		Set Ability Cooldown(Event Player, Button(Ability 1), 2 + 4 * (Count Of(All Living Players(All Teams)) / 12));
	}
}

rule("charge ready")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Wait(0.600, Abort When False);
		Event Player.isCharging = True;
	}
}

rule("charge ball")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == False;
		Event Player.isCharging == True;
	}

	actions
	{
		Cancel Primary Action(Event Player);
		"remove faux sphere"
		Destroy Effect(Event Player.chargeSphereArray[0]);
		Destroy Effect(Event Player.chargeSphereArray[1]);
		Event Player.chargeSphereArray = 0;
		"no more than 3 balls at a time"
		If(Count Of(Filtered Array(Event Player.ballPosArray, Current Array Element != Global.INACTIVE_BALL_POS)) >= 3);
			Call Subroutine(destroyOldestBall);
		End;
		Global.singleTickTemp = Index Of Array Value(Event Player.ballPosArray, Global.INACTIVE_BALL_POS);
		Event Player.ballPosArray[Global.singleTickTemp] = Eye Position(Event Player);
		Event Player.ballVelArray[Global.singleTickTemp] = 20 * Facing Direction Of(Event Player);
		Event Player.ballRadArray[Global.singleTickTemp] = Event Player.chargeRad;
		Event Player.ballTimerArray[Global.singleTickTemp] = 0;
		Event Player.isCharging = False;
		Wait(0.016, Ignore Condition);
		"Cooldown shortens with smaller number of players alive"
		Set Ability Cooldown(Event Player, Button(Ability 2), 2 + 4 * (Count Of(All Living Players(All Teams)) / 12));
		Set Ability Cooldown(Event Player, Button(Ability 1), 2 + 4 * (Count Of(All Living Players(All Teams)) / 12));
	}
}

rule("kill ult charge")
{
	event
	{
		Player Dealt Final Blow;
		All;
		All;
	}

	conditions
	{
		Event Player.ultPercent < 100;
	}

	actions
	{
		Event Player.ultPercent += 25;
	}
}

rule("ult set to 0 percent")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Ultimate) == True;
		Ultimate Charge Percent(Event Player) == 0;
	}

	actions
	{
		Event Player.ultPercent = 0;
	}
}